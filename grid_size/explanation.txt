Wind and data sources (conceptually)
You do not model tornados; you model a gridded wind field (forecast/analysis).

Typical approach:

Download wind data on a regular lat/lon grid and fixed flight level: each grid cell has a vector (u,v) = west–east, south–north components.

For each node (waypoint), interpolate from the surrounding grid points to get the local wind vector at that lat/lon.

For an edge from A→B, approximate wind at the midpoint or average of A and B’s wind vectors.

Compute course bearing from A→B, project the wind vector onto that bearing to get head/tail component, derive groundspeed, then time and fuel.

There are global open sources with wind on grids (NOAA GFS, ECMWF reanalysis, etc.), but the exact data retrieval is an implementation detail we can park for later; conceptually, what matters is: for any lat/lon/alt, you can get a representative wind vector and plug it into the edge‑cost formula.




def calculate_edge_cost(nodeA, nodeB, aircraft_weight, mach, altitude,
                        PDB, wind_field, ANSP_rates, cost_index,
                        T_target, T_current):
    """
    Calculate total cost of flying from nodeA to nodeB.

    Returns:
        total_cost (float): in € or kg-equivalent
        time_hours (float): segment flight time
    """

    # 1. DISTANCE & BEARING
    lat_A, lon_A = nodeA
    lat_B, lon_B = nodeB
    distance_m = haversine(lat_A, lon_A, lat_B, lon_B)  # great circle
    distance_nm = distance_m * 0.000539957
    distance_km = distance_m / 1000
    bearing = calculate_bearing(lat_A, lon_A, lat_B, lon_B)

    # 2. WIND CORRECTION
    mid_lat = (lat_A + lat_B) / 2
    mid_lon = (lon_A + lon_B) / 2
    u_wind, v_wind = wind_field(mid_lat, mid_lon, altitude)

    # Convert wind to head/tail component
    wind_speed_ms = sqrt(u_wind**2 + v_wind**2)
    wind_direction = atan2(v_wind, u_wind)  # radians
    wind_angle = bearing - wind_direction
    headwind_component_ms = wind_speed_ms * cos(wind_angle)
    headwind_component_kts = headwind_component_ms * 1.94384  # m/s to knots

    # 3. TRUE AIRSPEED (from Mach + altitude)
    temp_K = ISA_temperature(altitude)  # Standard atmosphere
    speed_of_sound_kts = 38.967854 * sqrt(temp_K)  # kt
    TAS_kts = mach * speed_of_sound_kts

    # 4. GROUNDSPEED
    GS_kts = TAS_kts + headwind_component_kts  # positive headwind reduces GS

    # 5. FLIGHT TIME
    time_hours = distance_nm / GS_kts

    # 6. FUEL FLOW (from PDB interpolation)
    fuel_flow_kg_per_hr = interpolate_PDB(aircraft_weight, mach, altitude, PDB)

    # 7. FUEL BURNED
    fuel_kg = fuel_flow_kg_per_hr * time_hours

    # 8. FUEL COST (convert to €)
    fuel_price_per_kg = 0.80  # €/kg (typical Jet-A1 price, adjust as needed)
    fuel_cost_EUR = fuel_kg * fuel_price_per_kg

    # 9. TIME COST (via Cost Index)
    # CI units: kg fuel / minute of time
    # time_cost = (time in minutes) * CI * fuel_price
    time_cost_EUR = (time_hours * 60) * cost_index * fuel_price_per_kg

    # 10. ANSP COST
    # Determine which FIR(s) this segment crosses
    FIR_list = determine_FIRs(lat_A, lon_A, lat_B, lon_B)  # e.g., ['EHAM', 'EGTT', 'NAT']
    ansp_cost_EUR = 0
    for fir in FIR_list:
        rate_per_nm = ANSP_rates[fir]  # €/nm
        # Approximate: split distance proportionally across FIRs
        segment_distance_in_fir = distance_nm / len(FIR_list)  # crude approximation
        ansp_cost_EUR += rate_per_nm * segment_distance_in_fir

    # 11. RTA PENALTY (accumulated after path is complete, but tracked per edge)
    # For edge cost, we don't penalize yet—just track time
    # Penalty applied at path level: cost += penalty_weight * |sum(edge_times) - T_target|

    # 12. TOTAL EDGE COST
    total_cost = fuel_cost_EUR + time_cost_EUR + ansp_cost_EUR

    return total_cost, time_hours