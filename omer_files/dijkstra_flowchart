// Dynamic Dijkstra Flowchart
digraph {
	rankdir=TB size="8,12"
	node [fillcolor="#E3F2FD" fontname=Arial shape=box style=filled]
	Start [label="Start
(Init Queue: StartNode, Time=0, Weight=Initial)" fillcolor="#C8E6C9" shape=oval]
	QueueCheck [label="Is Queue Empty?" fillcolor="#FFE0B2" shape=diamond]
	NoPath [label="No Path Found" fillcolor="#FFCDD2" shape=oval]
	Pop [label="Pop Lowest Cost State
(cost, u, time, weight)"]
	GoalCheck [label="Is Node (u) == Destination?" fillcolor="#FFE0B2" shape=diamond]
	End [label="Reconstruct Path & Return
(Apply ToA penalty if applicable)" fillcolor="#A5D6A7" shape=oval]
	Pruning [label="Is State Dominated?
(Pareto Check at time bin)" fillcolor="#FFCDD2" shape=diamond]
	DiscardDominated [label="Discard State
(Dominated)" fillcolor="#EF9A9A" shape=oval]
	UpdatePareto [label="Update Pareto Frontier
(Remove dominated states)"]
	Expand [label="For Each Neighbor (v)
in Adjacency List"]
	Physics [label="Physics Engine:
1. Get Wind @ Time
2. Calc Fuel Burn & Time
3. Calc Segment Cost"]
	CalcNewState [label="Calculate New State:
new_cost = cost + segment_cost
new_weight = weight - fuel_burn
new_time = time + segment_time"]
	Feasible [label="Is new_weight >= 0?" fillcolor="#FFCDD2" shape=diamond]
	SkipNeighbor [label="Skip Neighbor
(Infeasible)" fillcolor="#EF9A9A" shape=oval]
	ApplyPenalty [label="If v == Destination:
Apply ToA Penalty to cost"]
	Push [label="Push New State to Queue
(new_cost, v, new_time, new_weight)"]
	NextNeighbor [label="More Neighbors?" fillcolor="#FFE0B2" shape=diamond]
	Start -> QueueCheck
	QueueCheck -> Pop [label="No (has states)"]
	QueueCheck -> NoPath [label="Yes (empty)"]
	Pop -> GoalCheck
	GoalCheck -> End [label=Yes]
	GoalCheck -> Pruning [label=No]
	Pruning -> DiscardDominated [label=Yes]
	DiscardDominated -> QueueCheck [label="Loop Back" style=dashed]
	Pruning -> UpdatePareto [label=No]
	UpdatePareto -> Expand
	Expand -> Physics
	Physics -> CalcNewState
	CalcNewState -> Feasible
	Feasible -> SkipNeighbor [label="No (crash)"]
	Feasible -> ApplyPenalty [label=Yes]
	ApplyPenalty -> Push
	Push -> NextNeighbor
	SkipNeighbor -> NextNeighbor [style=dashed]
	NextNeighbor -> Expand [label=Yes style=dashed]
	NextNeighbor -> QueueCheck [label="No (all done)" style=dashed]
}
