Wind and data sources (conceptually)
You do not model tornados; you model a gridded wind field (forecast/analysis).

Typical approach:

Download wind data on a regular lat/lon grid and fixed flight level: each grid cell has a vector (u,v) = west–east, south–north components.

For each node (waypoint), interpolate from the surrounding grid points to get the local wind vector at that lat/lon.

For an edge from A→B, approximate wind at the midpoint or average of A and B’s wind vectors.

Compute course bearing from A→B, project the wind vector onto that bearing to get head/tail component, derive groundspeed, then time and fuel.

There are global open sources with wind on grids (NOAA GFS, ECMWF reanalysis, etc.), but the exact data retrieval is an implementation detail we can park for later; conceptually, what matters is: for any lat/lon/alt, you can get a representative wind vector and plug it into the edge‑cost formula.




def calculate_edge_cost(nodeA, nodeB, aircraft_weight, mach, altitude,
                        PDB, wind_field, ANSP_rates, cost_index,
                        T_target, T_current):
    """
    Calculate total cost of flying from nodeA to nodeB.

    Returns:
        total_cost (float): in € or kg-equivalent
        time_hours (float): segment flight time
    """

    # 1. DISTANCE & BEARING
    lat_A, lon_A = nodeA
    lat_B, lon_B = nodeB
    distance_m = haversine(lat_A, lon_A, lat_B, lon_B)  # great circle
    distance_nm = distance_m * 0.000539957
    distance_km = distance_m / 1000
    bearing = calculate_bearing(lat_A, lon_A, lat_B, lon_B)

    # 2. WIND CORRECTION
    mid_lat = (lat_A + lat_B) / 2
    mid_lon = (lon_A + lon_B) / 2
    u_wind, v_wind = wind_field(mid_lat, mid_lon, altitude)

    # Convert wind to head/tail component
    wind_speed_ms = sqrt(u_wind**2 + v_wind**2)
    wind_direction = atan2(v_wind, u_wind)  # radians
    wind_angle = bearing - wind_direction
    headwind_component_ms = wind_speed_ms * cos(wind_angle)
    headwind_component_kts = headwind_component_ms * 1.94384  # m/s to knots

    # 3. TRUE AIRSPEED (from Mach + altitude)
    temp_K = ISA_temperature(altitude)  # Standard atmosphere
    speed_of_sound_kts = 38.967854 * sqrt(temp_K)  # kt
    TAS_kts = mach * speed_of_sound_kts

    # 4. GROUNDSPEED
    GS_kts = TAS_kts + headwind_component_kts  # positive headwind reduces GS

    # 5. FLIGHT TIME
    time_hours = distance_nm / GS_kts

    # 6. FUEL FLOW (from PDB interpolation)
    fuel_flow_kg_per_hr = interpolate_PDB(aircraft_weight, mach, altitude, PDB)

    # 7. FUEL BURNED
    fuel_kg = fuel_flow_kg_per_hr * time_hours

    # 8. FUEL COST (convert to €)
    fuel_price_per_kg = 0.80  # €/kg (typical Jet-A1 price, adjust as needed)
    fuel_cost_EUR = fuel_kg * fuel_price_per_kg

    # 9. TIME COST (via Cost Index)
    # CI units: kg fuel / minute of time
    # time_cost = (time in minutes) * CI * fuel_price
    time_cost_EUR = (time_hours * 60) * cost_index * fuel_price_per_kg

    # 10. ANSP COST
    # Determine which FIR(s) this segment crosses
    FIR_list = determine_FIRs(lat_A, lon_A, lat_B, lon_B)  # e.g., ['EHAM', 'EGTT', 'NAT']
    ansp_cost_EUR = 0
    for fir in FIR_list:
        rate_per_nm = ANSP_rates[fir]  # €/nm
        # Approximate: split distance proportionally across FIRs
        segment_distance_in_fir = distance_nm / len(FIR_list)  # crude approximation
        ansp_cost_EUR += rate_per_nm * segment_distance_in_fir

    # 11. RTA PENALTY (accumulated after path is complete, but tracked per edge)
    # For edge cost, we don't penalize yet—just track time
    # Penalty applied at path level: cost += penalty_weight * |sum(edge_times) - T_target|

    # 12. TOTAL EDGE COST
    total_cost = fuel_cost_EUR + time_cost_EUR + ansp_cost_EUR

    return total_cost, time_hours



    Concrete, defensible grid spec
Here is a specific proposal that respects all three principles and keeps you <1,000 nodes:

1. Route and baseline
AMS–JFK great-circle distance ≈ 5,850–5,900 km.

You will build rings along this great-circle from AMS towards JFK.

2. Ring spacing (Δs)
Pick Δs = 250 km:

Number of rings ≈ 5,900 / 250 ≈ 24 rings (r = 0…23).

This yields about 23–24 segments along a typical path; that’s fine-grained for a 6,000 km trip.

You can later test 200 km spacing if needed; 250 km is a solid starting point.

3. Angular spread and step
Let maximum lateral deviation from the great-circle initial course be ±20°:

This roughly corresponds to lateral offsets of order 200–300 NM mid-Atlantic, which is realistic for wind and ANSP-driven reroutes.

Choose an angular step of 3° between samples along each ring.

That gives:

Angles: −20°, −17°, −14°, …, +17°, +20°.

15 points per ring (K = 15).

If later you feel this is too coarse, you can tighten to 2° (giving 21 points per ring).

4. Node count
With 24 rings and 15 angles:

Ring nodes = 24 × 15 = 360.

Plus AMS and JFK → total 362 nodes.

If you later move to 200 km spacing:

Rings ≈ 30, nodes = 30 × 15 = 450 + 2 ≈ 452 nodes.

Both are well within your computational comfort zone.

5. Turn angle per leg
Your neighbor rule (connect only to same angle index and ±1 on the next ring) implies:

Heading change per leg ≈ 3° (the angle step).

Over 250 km, that’s a gentle turn and aerodynamically plausible.

This ties the 3° step directly to dynamics: you can say in your report that you limit inter-leg heading changes to ≈3° to avoid unrealistic “jagged” routes.

Summary grid specification (what you can literally write down)
Ring spacing: 250 km along AMS–JFK great-circle.

Number of rings: 24 (r = 0…23).

Angles per ring: 15, at deviations θ_k = −20° + 3k, k = 0…14.

Nodes: 362 total (360 grid nodes + AMS + JFK).

Neighbor rule: From (r, k) connect to (r+1, k−1), (r+1, k), (r+1, k+1) within bounds; all nodes on last ring connect to JFK.

Justification:

250 km step resolves route curvature on a 6,000 km sector.

±20° spread covers realistic deviations (~±200–250 NM).

3° per ring ensures smooth, flyable turns.

Total node count keeps Dijkstra and the heuristic well within <30 s even for many runs.

If you can extract approximate node counts and spacing from one paper to echo (“similar to X”), that only strengthens this. But even without that, the above choices are logical and explainable.

If you’re happy with this spec, the next step is to define indexing and coordinate generation precisely: how to go from (r, k) to (lat, lon) using your Vincenty functions and from (r, k) to a unique node_id.



Ring spacing: 250 km along AMS–JFK great-circle.

Number of rings: 24 (r = 0…23).

Angles per ring: 15, at deviations θ_k = −20° + 3k, k = 0…14.

Nodes: 362 total (360 grid nodes + AMS + JFK).

Neighbor rule: From (r, k) connect to (r+1, k−1), (r+1, k), (r+1, k+1) within bounds; all nodes on last ring connect to JFK.

Justification:

250 km step resolves route curvature on a 6,000 km sector.

±20° spread covers realistic deviations (~±200–250 NM).

3° per ring ensures smooth, flyable turns.

Grid sizing: Moving to 29 rings × 21 angles (613 nodes) with 200 km spacing and 2° angular steps is well within your compute budget and more than enough resolution for a 5,800–6,000 km route. It’s denser than what the papers used but still small for Dijkstra and any heuristic.